# 并发编程原理

## Java内存模型

- 线程间如何通信？即：线程之间以何种机制来交换信息
- 线程间如何同步？即：线程以何种机制来控制不同线程间操作发生的相对顺序

有两种并发模型可以解决这两个问题：

- 消息传递并发模型
- 共享内存并发模型

**在Java中，使用的是共享内存并发模型**。那么上面两个问题：

线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。

必须显式指定某段代码需要在线程之间互斥执行，同步是显式的。

### Java内存模型的抽象结构

#### 运行时内存的划分

![Java运行时数据区域](https://raw.githubusercontent.com/Hitooooo/docs-my/main/uPic/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png)

对于每一个线程来说，栈都是私有的，而堆是共有的。

也就是说在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性（下文会说到）的问题，也不受内存模型的影响。而在堆中的变量是共享的，本文称为共享变量。

所以，内存可见性是针对的**共享变量**。

#### 既然堆是共享的，为什么在堆中会有内存不可见问题

**缓存，它加了缓存**

这是因为现代计算机为了高效，往往会在高速缓存区中缓存共享变量，因为cpu访问缓存区比访问内存要快得多。

> 线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本。本地内存是Java内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。

Java线程之间的通信由Java内存模型（简称JMM）控制，从抽象的角度来说，JMM定义了线程和主内存之间的抽象关系。JMM的抽象示意图如图所示：

```mermaid
flowchart TD
  threadA(线程A)
  memoryA("本地内存A.共享变量副本")
  threadB(线程B)
  memoryB("本地内存B.共享变量副本")
  
  threadA <--> memoryA
  threadB <--> memoryB
  memoryA <--JMM控制--> main
  memoryB <--JMM控制--> main
  
  subgraph main [主内存]
  	id1([共享变量])
  	id2([共享变量])
  	id3([共享变量])
  end
```

从图中可以看出：

1. 所有的共享变量都存在主内存中。
2. 每个线程都保存了一份该线程使用到的共享变量的副本。
3. 如果线程A与线程B之间要通信的话，必须经历下面2个步骤：
   1. 线程A将本地内存A中更新过的共享变量刷新到主内存中去。
   2. 线程B到主内存中去读取线程A之前已经更新过的共享变量。

**所以，线程A无法直接访问线程B的工作内存，线程间通信必须经过主内存。**

注意，根据JMM的规定，**线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取**。

所以线程B并不是直接去主内存中读取共享变量的值，而是先在本地内存B中找到这个共享变量，发现这个共享变量已经被更新了，然后本地内存B去主内存中读取这个共享变量的新值，并拷贝到本地内存B中，最后线程B再读取本地内存B中的新值。

那么怎么知道这个共享变量的被其他线程更新了呢？这就是JMM的功劳了，也是JMM存在的必要性之一。**JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证**。

* Java中的**volatile**关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序
* **synchronized**关键字不仅保证可见性，同时也保证了原子性（互斥性）
* 在更底层，JMM通过内存屏障来实现内存的可见性以及禁止重排序。为了程序员的方便理解，提出了**happens-before**，它更加的简单易懂，从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则以及这些规则的具体实现方法。

#### JMM与Java内存区域划分的区别与联系

- 区别

  两者是不同的概念层次。**JMM是抽象的**，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。而**Java运行时内存的划分是具体的**，是JVM运行Java程序时，必要的内存划分。

- 联系

  都存在私有数据区域和共享数据区域。一般来说，JMM中的主内存属于共享数据区域，他是包含了堆和方法区；同样，JMM中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。

## 重排序和happens-before

上节说到JMM模型使用volatile、synchronized和happens-before等方式控制主存和各个本地内存之间的交互

### 什么是重排序

### 顺序一致性模型与JMM的保证

### happens-before

## volatile



## synchronized与锁



## CAS和原子操作



## AQS





- [ ] 阻塞队列原理
- [ ] synchronized原理
